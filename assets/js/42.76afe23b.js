(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{433:function(e,t,a){"use strict";a.r(t);var n=a(9),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("This blog explains, what is AmpliGraph and how to use it.")]),e._v(" "),a("p",[a("strong",[e._v("What is AmpliGraph?")])]),e._v(" "),a("p",[a("strong",[e._v("AmpliGraph")]),e._v(" is a suite of neural machine learning models for relational Learning, a branch of machine learning that deals with supervised learning on knowledge graphs.")]),e._v(" "),a("p",[a("strong",[e._v("Use AmpliGraph if you need to:")])]),e._v(" "),a("ul",[a("li",[e._v("Discover new knowledge from an existing knowledge graph.")]),e._v(" "),a("li",[e._v("Complete large knowledge graphs with missing statements.")]),e._v(" "),a("li",[e._v("Generate stand-alone knowledge graph embeddings.")]),e._v(" "),a("li",[e._v("Develop and evaluate a new relational model.")])]),e._v(" "),a("p",[e._v("AmpliGraph’s machine learning models generate "),a("strong",[e._v("knowledge graph embeddings")]),e._v(", vector representations of concepts in metric space:")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*HJ-zEj-9_TVGZmrxTRvPZQ.png",alt:"Feature"}})]),e._v(" "),a("p",[e._v("It then combines embeddings with model-specific scoring functions to predict unseen and novel links:")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*XwaVbdVCjLT518a58RXzrw.png",alt:"Feature"}})]),e._v(" "),a("p",[e._v("Data-Flow in knowledge graph:")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/625/1*TOuZ1fw6-XWFbLevuVjiCA.png",alt:"Feature"}})]),e._v(" "),a("p",[a("strong",[e._v("AmpliGraph API")]),e._v(" includes the following submodules:")]),e._v(" "),a("ul",[a("li",[e._v("Datasets")]),e._v(" "),a("li",[e._v("Models")]),e._v(" "),a("li",[e._v("Evaluation")]),e._v(" "),a("li",[e._v("Discovery")]),e._v(" "),a("li",[e._v("Utils")])]),e._v(" "),a("p",[a("strong",[e._v("Installation")])]),e._v(" "),a("p",[a("strong",[e._v("Prerequisites")])]),e._v(" "),a("ul",[a("li",[e._v("Linux, macOS, Windows")]),e._v(" "),a("li",[e._v("Python ≥ 3.7")])]),e._v(" "),a("p",[a("strong",[e._v("Provision a Virtual Environment")]),e._v("\nCreate and activate a virtual environment (conda)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("conda create --name ampligraph python=3.7\nsource activate ampligraph\n")])])]),a("p",[e._v("Install AmpliGraph\nInstall the latest stable release from pip:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("pip install ampligraph\n")])])]),a("p",[e._v("If instead, you want the most recent development version, you can clone the repository and install from source as below (also see the How to Contribute guide for details):")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("git clone https://github.com/Accenture/AmpliGraph.git\ncd AmpliGraph\ngit checkout develop\npip install -e .\n")])])]),a("p",[e._v("Sanity Check")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(">> import ampligraph\n>> ampligraph.__version__\n'1.3.2'\n")])])]),a("p",[e._v("Now we are going to use Game of Thrones data to plot the Ampligraph")]),e._v(" "),a("p",[e._v("Please note: This isn’t the greatest dataset for demonstrating the power of knowledge graph embeddings, but is small, intuitive and should be familiar to most users.")]),e._v(" "),a("p",[e._v("Let’s get Started with AmpliGraph")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://tenor.com/view/type-typing-keyboard-computer-fast-typing-gif-4748677",alt:"Feature"}})]),e._v(" "),a("p",[a("strong",[e._v("1. Dataset exploration")]),e._v("\nFirst things first! Let's import the required libraries and retrieve some data.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import requests\nfrom ampligraph.datasets import load_from_csv\nurl = 'https://ampligraph.s3-eu-west-1.amazonaws.com/datasets/GoT.csv'\nopen('GoT.csv', 'wb').write(requests.get(url).content\nX = load_from_csv('.', 'GoT.csv', sep=',')\nX[:5, ]\n")])])]),a("p",[e._v("The Output is,")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("array([[‘Smithyton’, ‘SEAT_OF’, ‘House Shermer of Smithyton’], [‘House Mormont of Bear Island’, ‘LED_BY’, ‘Maege Mormont’], [‘Margaery Tyrell’, ‘SPOUSE’, ‘Joffrey Baratheon’], [‘Maron Nymeros Martell’, ‘ALLIED_WITH’, ‘House Nymeros Martell of Sunspear’], [‘House Gargalen of Salt Shore’, ‘IN_REGION’, ‘Dorne’]], dtype=object)\n")])])]),a("p",[a("strong",[e._v("2. Defining train and test datasets")])]),e._v(" "),a("p",[e._v("As is typical in machine learning, we need to split our dataset into training and test (and sometimes validation) datasets. What differs from the standard method of randomly sampling N points to make up our test set, is that our data points are two entities linked by some relationship, and we need to take care to ensure that all entities are represented in train and test sets by at least 1 triple. To accomplish AmpliGraph provides the train_test_split_no_unseen function.")]),e._v(" "),a("p",[e._v("We’ll stick to common practice and divide our training and test set in an 80/20 split.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from ampligraph.evaluation import train_test_split_no_unseen \n\nnum_test = int(len(X) * (20 / 100))\n\ndata = {}\ndata['train'], data['test'] = train_test_split_no_unseen(X, test_size=num_test, seed=0, allow_duplication=False) \n\nprint('Train set size: ', data['train'].shape)\nprint('Test set size: ', data['test'].shape)\n")])])]),a("p",[a("strong",[e._v("3. Training a model")])]),e._v(" "),a("p",[e._v("AmpliGraph has implemented several Graph embedding models (TransE, ComplEx, DistMult, HolE), but to begin with, we’re just going to use the ComplEx model (with default values).\nLet’s go through the parameters to understand what’s going on:")]),e._v(" "),a("ul",[a("li",[e._v("k : the dimensionality of the embedding space")]),e._v(" "),a("li",[e._v("eta (η): the number of negative, or false triples that must be generated at training runtime for each positive, or true triple")]),e._v(" "),a("li",[e._v("batches_count : the number of batches in which the training set is split during the training loop. If you are having into low memory issues than settings this to a higher number may help.")]),e._v(" "),a("li",[e._v("epochs : the number of epochs to train the model for.")]),e._v(" "),a("li",[e._v("optimizer : the Adam optimizer, with a learning rate of 1e-3 set via the optimizer_params kwarg.")]),e._v(" "),a("li",[e._v("loss : pairwise loss, with a margin of 0.5 sets via the loss_params kwarg.")]),e._v(" "),a("li",[e._v("regularizer : Lp regularization with p=2, i.e. l2 regularization. λ = 1e-5, set via the regularizer_params kwarg.")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from ampligraph.latent_features import ComplEx\n\nmodel = ComplEx(batches_count=100, \n                seed=0, \n                epochs=200, \n                k=150, \n                eta=5,\n                optimizer='adam', \n                optimizer_params={'lr':1e-3},\n                loss='multiclass_nll', \n                regularizer='LP', \n                regularizer_params={'p':3, 'lambda':1e-5}, \n                verbose=True)\n")])])]),a("p",[a("strong",[e._v("4. Fitting the model")]),e._v("\nOnce you run the next cell the model will train.")]),e._v(" "),a("p",[e._v("On a modern laptop, this should take ~3 minutes (although your mileage may vary, especially if you’ve changed any of the hyper-parameters above).")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import tensorflow as tf\ntf.logging.set_verbosity(tf.logging.ERROR)\n\nmodel.fit(data['train'], early_stopping = False)\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Average Loss:   0.021658: 100%|██████████| 200/200 [01:28<00:00,  2.25epoch/s]\n")])])]),a("p",[a("strong",[e._v("5. Evaluating a model")]),e._v("\nNow it’s time to evaluate our model on the test set to see how well it’s performing.")]),e._v(" "),a("p",[e._v("For this, we’ll use the evaluate_performance function and let’s look at the arguments to this function:")]),e._v(" "),a("ul",[a("li",[e._v("X - the data to evaluate. We're going to use our test set to evaluate.\nmodel - the model we previously trained.")]),e._v(" "),a("li",[e._v("filter_triples - will filter out the false negatives generated by the corruption strategy.")]),e._v(" "),a("li",[e._v("use_default_protocol - specifies whether to use the default corruption protocol. If True, then subj and obj are corrupted separately during evaluation.")]),e._v(" "),a("li",[e._v("verbose - will give some nice log statements. Let's leave it on for now.")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from ampligraph.evaluation import evaluate_performance\n\nranks = evaluate_performance(data['test'], \n                             model=model, \n                             filter_triples=positives_filter,   # Corruption strategy filter defined above \n                             use_default_protocol=True, # corrupt subj and obj separately while evaluating\n                             verbose=True)\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("WARNING - DeprecationWarning: use_default_protocol will be removed in future. Please use corrupt_side argument instead.\n100%|██████████| 635/635 [00:02<00:00, 288.28it/s]\n")])])]),a("p",[e._v("The ranks returned by the evaluate_performance function indicate the rank at which the test set triple was found when performing link prediction using the model.")]),e._v(" "),a("p",[e._v("For example, given the triple:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<House Stark of Winterfell, IN_REGION The North>\n")])])]),a("p",[e._v("The model returns a rank of 7. This tells us that while it’s not the highest likelihood true statement (which would be given a rank 1), it’s pretty likely.")]),e._v(" "),a("p",[a("strong",[e._v("6. Metrics")]),e._v("\nLet’s compute some evaluate metrics and print them out.\nWe’re going to use the mrr_score (mean reciprocal rank) and hits_at_n_score functions.")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("mrr_score:")]),e._v(" The function computes the mean of the reciprocal of elements of a vector of rankings ranks.")]),e._v(" "),a("li",[a("strong",[e._v("hits_at_n_score:")]),e._v(" The function computes how many elements of a vector of rankings ranks make it to the top n positions.")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('from ampligraph.evaluation import mr_score, mrr_score, hits_at_n_score\n\nmrr = mrr_score(ranks)\nprint("MRR: %.2f" % (mrr))\n\nhits_10 = hits_at_n_score(ranks, n=10)\nprint("Hits@10: %.2f" % (hits_10))\nhits_3 = hits_at_n_score(ranks, n=3)\nprint("Hits@3: %.2f" % (hits_3))\nhits_1 = hits_at_n_score(ranks, n=1)\nprint("Hits@1: %.2f" % (hits_1))\n')])])]),a("p",[e._v("And the output is,")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("MRR: 0.30\nHits@10: 0.41\nHits@3: 0.33\nHits@1: 0.24\n")])])]),a("p",[a("strong",[e._v("7. Predicting New Links")]),e._v("\nLink prediction allows us to infer missing links in a graph. This has many real-world use cases, such as predicting connections between people in a social network, interactions between proteins in a biological network, and music recommendation based on prior user taste.")]),e._v(" "),a("p",[e._v("In our case, we’re going to see which of the following candidate statements (that we made up) are more likely to be true:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("X_unseen = np.array([\n    ['Jorah Mormont', 'SPOUSE', 'Daenerys Targaryen'],\n    ['Tyrion Lannister', 'SPOUSE', 'Missandei'],\n    [\"King's Landing\", 'SEAT_OF', 'House Lannister of Casterly Rock'],\n    ['Sansa Stark', 'SPOUSE', 'Petyr Baelish'],\n    ['Daenerys Targaryen', 'SPOUSE', 'Jon Snow'],\n    ['Daenerys Targaryen', 'SPOUSE', 'Craster'],\n    ['House Stark of Winterfell', 'IN_REGION', 'The North'],\n    ['House Stark of Winterfell', 'IN_REGION', 'Dorne'],\n    ['House Tyrell of Highgarden', 'IN_REGION', 'Beyond the Wall'],\n    ['Brandon Stark', 'ALLIED_WITH', 'House Stark of Winterfell'],\n    ['Brandon Stark', 'ALLIED_WITH', 'House Lannister of Casterly Rock'],    \n    ['Rhaegar Targaryen', 'PARENT_OF', 'Jon Snow'],\n    ['House Hutcheson', 'SWORN_TO', 'House Tyrell of Highgarden'],\n    ['Daenerys Targaryen', 'ALLIED_WITH', 'House Stark of Winterfell'],\n    ['Daenerys Targaryen', 'ALLIED_WITH', 'House Lannister of Casterly Rock'],\n    ['Jaime Lannister', 'PARENT_OF', 'Myrcella Baratheon'],\n    ['Robert I Baratheon', 'PARENT_OF', 'Myrcella Baratheon'],\n    ['Cersei Lannister', 'PARENT_OF', 'Myrcella Baratheon'],\n    ['Cersei Lannister', 'PARENT_OF', 'Brandon Stark'],\n    [\"Tywin Lannister\", 'PARENT_OF', 'Jaime Lannister'],\n    [\"Missandei\", 'SPOUSE', 'Grey Worm'],\n    [\"Brienne of Tarth\", 'SPOUSE', 'Jaime Lannister']\n])\n\nunseen_filter = np.array(list({tuple(i) for i in np.vstack((positives_filter, X_unseen))}))\n\nranks_unseen = evaluate_performance(\n    X_unseen, \n    model=model, \n    filter_triples=unseen_filter,   # Corruption strategy filter defined above \n    corrupt_side = 's+o',\n    use_default_protocol=False, # corrupt subj and obj separately while evaluating\n    verbose=True\n)\n\nscores = model.predict(X_unseen)\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("100%|██████████| 22/22 [00:00<00:00, 159.31it/s]\n")])])]),a("p",[e._v("We transform the scores (real numbers) into probabilities (bound between 0 and 1) using the expit transform.")]),e._v(" "),a("p",[e._v("Note that the probabilities are not calibrated in any sense.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from scipy.special import expit\nprobs = expit(scores)\n\npd.DataFrame(list(zip([' '.join(x) for x in X_unseen], \n                      ranks_unseen, \n                      np.squeeze(scores),\n                      np.squeeze(probs))), \n             columns=['statement', 'rank', 'score', 'prob']).sort_values(\"score\")\n\n")])])]),a("p",[e._v("The resulting DataFrame,")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*VIYQcORe0ZsDBFpLJp5gXQ.png",alt:"Feature"}})]),e._v(" "),a("p",[a("strong",[e._v("8. Visualizing Embeddings with Tensorboard projector")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from ampligraph.utils import create_tensorboard_visualizations\n\ncreate_tensorboard_visualizations(model, 'GoT_embeddings')\n")])])]),a("p",[e._v("If all went well, we should now have several files in the AmpliGraph/tutorials/GoT_embeddings directory:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("GoT_embeddings/\n    ├── checkpoint\n    ├── embeddings_projector.tsv\n    ├── graph_embedding.ckpt.data-00000-of-00001\n    ├── graph_embedding.ckpt.index\n    ├── graph_embedding.ckpt.meta\n    ├── metadata.tsv\n    └── projector_config.pbtxt\n")])])]),a("p",[e._v("To visualize the embeddings in Tensorboard, run the following from your command line inside AmpliGraph/tutorials:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("tensorboard --logdir=./visualizations\n")])])]),a("p",[e._v(".. and once your browser opens up you should be able to see and explore your embeddings as below (PCA-reduced, two components):")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*YLShfpuKaHgMnZJ8rMbjzQ.png",alt:"Feature"}})]),e._v(" "),a("p",[a("strong",[e._v("Conclusion")])]),e._v(" "),a("p",[e._v("In summary, AmpliGraph Graphs are at the crossroads of Data Base and Artificial intelligence to provide smart insights (or Knowledge) from very different types of data. Decision-makers can store all business knowledge as a set of connected vectors and use artificial neural networks to reason using this information.")]),e._v(" "),a("p",[e._v("The source code of AmpliGraph Library is available here")])])}),[],!1,null,null,null);t.default=s.exports}}]);